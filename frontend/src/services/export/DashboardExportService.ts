// Dashboard Export Service - Phase B Sprint 1 Day 4
// Export dashboards to PDF, Excel, and image formats

import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';

interface ExportOptions {
  filename?: string;
  format: 'pdf' | 'excel' | 'png' | 'jpeg';
  quality?: number;
  includeCharts?: boolean;
  includeMetadata?: boolean;
  orientation?: 'portrait' | 'landscape';
}

interface DashboardData {
  title: string;
  widgets: {
    id: string;
    title: string;
    type: string;
    data: any;
    position: { x: number; y: number; w: number; h: number };
  }[];
  metadata: {
    generatedAt: string;
    generatedBy: string;
    department?: string;
    period?: string;
  };
}

class DashboardExportService {
  
  // Export dashboard as PDF
  async exportToPDF(
    dashboardElement: HTMLElement, 
    dashboardData: DashboardData,
    options: ExportOptions = { format: 'pdf' }
  ): Promise<void> {
    try {
      // Capture dashboard as canvas
      const canvas = await html2canvas(dashboardElement, {
        scale: 2, // Higher resolution
        useCORS: true,
        logging: false,
        backgroundColor: '#ffffff'
      });

      const imgData = canvas.toDataURL('image/png');
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;

      // Create PDF
      const orientation = options.orientation || 'landscape';
      const pdf = new jsPDF(orientation, 'mm', 'a4');
      
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();
      
      // Calculate scaling to fit page
      const ratio = Math.min(pdfWidth / imgWidth * 72 / 96, pdfHeight / imgHeight * 72 / 96);
      const scaledWidth = imgWidth * ratio * 96 / 72;
      const scaledHeight = imgHeight * ratio * 96 / 72;
      
      // Center image on page
      const x = (pdfWidth - scaledWidth) / 2;
      const y = (pdfHeight - scaledHeight) / 2;

      // Add header
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(dashboardData.title, pdfWidth / 2, 15, { align: 'center' });
      
      // Add metadata
      if (options.includeMetadata) {
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        pdf.text(`Generated: ${dashboardData.metadata.generatedAt}`, 10, 25);
        pdf.text(`By: ${dashboardData.metadata.generatedBy}`, 10, 30);
        if (dashboardData.metadata.department) {
          pdf.text(`Department: ${dashboardData.metadata.department}`, 10, 35);
        }
      }

      // Add dashboard image
      pdf.addImage(imgData, 'PNG', x, y + 20, scaledWidth, scaledHeight);
      
      // Add footer
      const pageCount = pdf.internal.getNumberOfPages();
      pdf.setFontSize(8);
      pdf.text(`Page 1 of ${pageCount}`, pdfWidth - 20, pdfHeight - 5);

      // Save PDF
      const filename = options.filename || `${dashboardData.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      pdf.save(filename);

    } catch (error) {
      console.error('Error exporting to PDF:', error);
      throw new Error('Failed to export dashboard as PDF');
    }
  }

  // Export dashboard data as Excel
  async exportToExcel(
    dashboardData: DashboardData,
    options: ExportOptions = { format: 'excel' }
  ): Promise<void> {
    try {
      const workbook = XLSX.utils.book_new();

      // Create summary sheet
      const summaryData = [
        ['Dashboard Title', dashboardData.title],
        ['Generated At', dashboardData.metadata.generatedAt],
        ['Generated By', dashboardData.metadata.generatedBy],
        ['Department', dashboardData.metadata.department || 'All'],
        ['Period', dashboardData.metadata.period || 'Current'],
        [],
        ['Widget Summary'],
        ['Widget ID', 'Title', 'Type', 'Position']
      ];

      dashboardData.widgets.forEach(widget => {
        summaryData.push([
          widget.id,
          widget.title,
          widget.type,
          `${widget.position.x},${widget.position.y} (${widget.position.w}x${widget.position.h})`
        ]);
      });

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

      // Create data sheets for each widget
      dashboardData.widgets.forEach(widget => {
        if (widget.data && widget.type !== 'chart') {
          let sheetData: any[][] = [];
          
          if (widget.type === 'kpi') {
            sheetData = [
              ['Metric', 'Value'],
              ['Current Value', widget.data.value || 'N/A'],
              ['Unit', widget.data.unit || 'N/A'],
              ['Previous Value', widget.data.previousValue || 'N/A'],
              ['Target', widget.data.target || 'N/A'],
              ['Trend', widget.data.trend || 'N/A'],
              ['Status', widget.data.status || 'N/A']
            ];
          } else if (widget.type === 'table') {
            // Handle table data
            if (Array.isArray(widget.data)) {
              const headers = Object.keys(widget.data[0] || {});
              sheetData = [headers, ...widget.data.map(row => headers.map(h => row[h]))];
            }
          } else if (widget.type === 'chart' && widget.data.datasets) {
            // Handle chart data
            const labels = widget.data.labels || [];
            sheetData = [['Label', ...widget.data.datasets.map((d: any) => d.label)]];
            
            labels.forEach((label: string, index: number) => {
              const row = [label];
              widget.data.datasets.forEach((dataset: any) => {
                row.push(dataset.data[index] || 'N/A');
              });
              sheetData.push(row);
            });
          }

          if (sheetData.length > 0) {
            const sheet = XLSX.utils.aoa_to_sheet(sheetData);
            const sheetName = widget.title.replace(/[^\w\s]/gi, '').substring(0, 30);
            XLSX.utils.book_append_sheet(workbook, sheet, sheetName);
          }
        }
      });

      // Save Excel file
      const filename = options.filename || `${dashboardData.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(workbook, filename);

    } catch (error) {
      console.error('Error exporting to Excel:', error);
      throw new Error('Failed to export dashboard as Excel');
    }
  }

  // Export dashboard as image
  async exportToImage(
    dashboardElement: HTMLElement,
    dashboardData: DashboardData,
    options: ExportOptions = { format: 'png' }
  ): Promise<void> {
    try {
      const canvas = await html2canvas(dashboardElement, {
        scale: options.quality || 2,
        useCORS: true,
        logging: false,
        backgroundColor: '#ffffff'
      });

      // Convert to desired format
      const format = options.format === 'jpeg' ? 'image/jpeg' : 'image/png';
      const quality = options.format === 'jpeg' ? 0.9 : undefined;
      
      canvas.toBlob((blob) => {
        if (blob) {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = options.filename || 
            `${dashboardData.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.${options.format}`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }
      }, format, quality);

    } catch (error) {
      console.error('Error exporting to image:', error);
      throw new Error(`Failed to export dashboard as ${options.format.toUpperCase()}`);
    }
  }

  // Export individual widget
  async exportWidget(
    widgetElement: HTMLElement,
    widgetData: any,
    options: ExportOptions
  ): Promise<void> {
    const dashboardData: DashboardData = {
      title: widgetData.title || 'Widget Export',
      widgets: [{
        id: 'widget-1',
        title: widgetData.title || 'Widget',
        type: widgetData.type || 'unknown',
        data: widgetData.data,
        position: { x: 0, y: 0, w: 12, h: 6 }
      }],
      metadata: {
        generatedAt: new Date().toISOString(),
        generatedBy: 'QMS User'
      }
    };

    switch (options.format) {
      case 'pdf':
        return this.exportToPDF(widgetElement, dashboardData, options);
      case 'excel':
        return this.exportToExcel(dashboardData, options);
      case 'png':
      case 'jpeg':
        return this.exportToImage(widgetElement, dashboardData, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }

  // Validate export requirements
  validateExportRequirements(): { canExport: boolean; missingFeatures: string[] } {
    const missingFeatures: string[] = [];

    // Check for required libraries
    if (typeof html2canvas === 'undefined') {
      missingFeatures.push('html2canvas library for image capture');
    }
    
    if (typeof jsPDF === 'undefined') {
      missingFeatures.push('jsPDF library for PDF generation');
    }
    
    if (typeof XLSX === 'undefined') {
      missingFeatures.push('xlsx library for Excel export');
    }

    // Check browser capabilities
    if (!document.createElement('canvas').getContext) {
      missingFeatures.push('Canvas support');
    }

    if (!window.Blob) {
      missingFeatures.push('Blob support');
    }

    return {
      canExport: missingFeatures.length === 0,
      missingFeatures
    };
  }

  // Get supported export formats
  getSupportedFormats(): string[] {
    const validation = this.validateExportRequirements();
    if (!validation.canExport) {
      return [];
    }
    
    return ['pdf', 'excel', 'png', 'jpeg'];
  }
}

// Global instance
export const dashboardExportService = new DashboardExportService();
export default DashboardExportService;